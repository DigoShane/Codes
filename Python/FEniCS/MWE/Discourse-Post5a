**Version**:-
DOLFIN version: 2019.1.0 run using Conda

**Motivation**:-
I have a code where I have to evolve a discontinuous variable ($\theta$). At each step, I will evolve this variable via gradient descent,
$\theta_{t+1}=\theta_t-\lambda\dfrac{\partial E^t}{\partial\theta},$
where $\lambda\approx0.01$ is the learning rate.
The variable $\theta$ is multivalued, but for my purposes, I want to restrict it to $[0,2\pi)$. Note that the actual $\theta$ being multivalued-continuous, the gradient is well defined. But restricting it to $[0,2\pi)$, means that we get a "fake" gradient at the 'line' of discontinuity. Thus, I want to modify $\dfrac{\partial E^t}{\partial\theta}$ near the discontinuity. This is the reason I need to keep track of this discontinuity. 

**Approach**:-
My current approach was to read in the function, return the values at the nodes, and test which nodal values are 0 or 2\pi. However, this approach fails since it does not return any nodes at all. Please check the MWE below.

**MWE**:-
The domain is a rectangle $l_x\times l_y$, which i discretize into $N_x$ by $N_y$. I provide an expression $T$ that is supposed to be the read-in value of $\theta$; this is discontinuous. I define Tarray as the array of nodal values for the function $T$. I define two functions Marker and Marker1 which I use to create mark the curve (for me nodes) of discontinuity. I initialize them to $-\pi$, get their nodal values in Marker_array and Marker_array1. I then loop over the nodal values of T to check if any one of them is equal to $0$ or $2\pi$; if there are, then I modify the corresponding value of Marker(1) to $2\pi$. To test if there are nodal values equal to $0$ or $2\pi$, I use the "np.where" command, and it doesn't return anything. Finally, I plot $\theta$ (colormap), and I plot the nodal values of Marker, Marker1 and T. Marker and Marker 1 should be discontinuous and should mark the "line" (here) node of discontinuity.

The scatter plot is to help me visualize the problem. Honestly, for this MWE, you can run the code till
*print("location of 0's", np.where( np.array(Tarray) == 0))*
*print("location of 2*pi's", np.where( np.array(Tarray) == 2*np.pi))*

```
import dolfin
print(f"DOLFIN version: {dolfin.__version__}")
from dolfin import *
import fenics as fe
import numpy as np
import ufl
print(f" UFL version: {ufl.__version__}")
from ufl import tanh
import matplotlib.pyplot as plt

import sys
np.set_printoptions(threshold=sys.maxsize)

#Parameters
pord = int(1)# degree of polynmomials used for FEA
lx = float(1.0)
ly = float(1.0)
Nx = int(40)
Ny = int(40)


#Create mesh and define function space
mesh = RectangleMesh(Point(0., 0.), Point(lx, ly), Nx, Ny) 
x = SpatialCoordinate(mesh)
V = FunctionSpace(mesh, "Lagrange", pord)

##Reading in function
T = interpolate( Expression('atan2(-0.5*(x[0]-0.5*lx)+rt*0.5*(x[1]-0.5*ly), 0.5*(x[1]-0.5*ly)+rt*0.5*(x[0]-0.5*lx) )', rt=np.sqrt(3), lx=lx, ly=ly, degree=pord), V)

###---------------------------------------------------------------------------------------------------------------
Tarray = T.vector()[:]

##====================================================================================================================
#Section of code to visualize the discontinuity.
Marker = interpolate( Expression('-pie', pie=np.pi, degree=pord), V)
Marker1 = interpolate( Expression('-pie', pie=np.pi, degree=pord), V)

Marker_array = Marker.vector()[:]
Marker_array1 = Marker1.vector()[:]
d2v = dof_to_vertex_map(V)

for i,t in enumerate(Tarray):
 if t == -np.pi + DOLFIN_EPS:
  Marker_array[d2v[i]] = 2*np.pi
 if t == np.pi - DOLFIN_EPS:
  Marker_array1[d2v[i]] = 2*np.pi

print("location of 0's", np.where( np.array(Tarray) == 0))
print("location of 2*pi's", np.where( np.array(Tarray) == 2*np.pi))

Marker.vector()[:] = Marker_array
Marker1.vector()[:] = Marker_array1

T.vector()[:] = Tarray

c = plot(T)
plt.title(r"$\theta$(x)",fontsize=26)
plt.colorbar(c)
plt.show()


n = V.dim()                                                                      
d = mesh.geometry().dim()                                                        
dof_coordinates = V.tabulate_dof_coordinates().reshape(n,d)                      
dof_coordinates.resize((n, d))                                                   
dof_x = dof_coordinates[:, 0]                                                    
dof_y = dof_coordinates[:, 1]                                                    


## Scatter plot to map discontinuity.
fig = plt.figure()                                                               
ax = fig.add_subplot(111, projection='3d')                                       
ax.scatter(dof_x, dof_y, T.vector()[:], c='b', marker='.')                  
ax.scatter(dof_x, dof_y, Marker.vector()[:], c='r', marker='.')                  
ax.scatter(dof_x, dof_y, Marker1.vector()[:], c='m', marker='.')                  
plt.xlabel("x")
plt.ylabel("y")
plt.show()                                                                       
```

**Help Request**:-
Can you help me write code that calculates the "curve"/"line" of discontinuity from the input function? I feel the approach via nodal values failed, but it will work if I have an approach that looks at functional values. Once I know the curve, I will be able to proceed with identifying the nodes lying on either side of it so that I can make some modifications there. 
